Also ich will heute mal ein Experiment wagen, wo ich praktisch eine andere Strategie anwende. Und du musst mir dabei helfen beim Coden. Also praktisch, dass wir auf eine andere Art und Weise an die Sache rangehen. Weil bisher verwirrt mich das alles. Ich kriege nie ein reproduzierbares Ergebnis hin. Und durch mein ADRS, je länger ich praktisch da sitze und durch diese ganzen Iterationen, wird es dann auch irgendwann anstrengend. Und deswegen muss ich da wie eine bessere Form finden. Und jetzt habe ich überlegt, du musst mir dabei helfen. Ich würde dir sagen, was ich denke. Und du würdest das erst mal so aufnehmen, ohne irgendwas dazu zu sagen. Bis ich sage, ich bin fertig. Und dann praktisch das mal gesamt analysieren und was dazu sagen.
Ja, und dazu kommt ja noch, dass ich praktisch so auch bei den irgendwelchen Fachbegriffen manchmal gar nicht weiß, was das bedeutet, aber da ja viele Sachen auch auf Englisch sind oder so und ich Englisch auch nicht kann, also nur Computerenglisch, sag ich jetzt mal so, ist das dann auch immer dementsprechend schwer, manche Sachen, denn obwohl ein ganz normaler Satz zum Beispiel bei GitHub ist oder so, kriege ich den trotzdem nicht verstanden, weil er halt im Fach Termini ist und auf Englisch und macht die Sache auch noch schwerer. Also müsste ich ja praktisch auch das alles so ein bisschen als Laie formuliert kriegen, aber kurz, also am besten wäre, wenn keine Wiederholung so über die Iteration kommt, sondern wir erweitern, immer aufbauen und sammeln und am Ende praktisch strukturieren und gucken, was wir haben.
So, das Problem ist dadurch, dass ich ja auch die ganzen Frameworks nicht kenne, weiß ich ja auch gar nicht, was es immer für Möglichkeiten gibt. Und meistens stellt sich dann am Ende raus, dass es dann doch eine viel, viel bessere und mit weniger Code-Variante gab, die schon viel ausgereifter ist oder so. Und dadurch, dass ich es nicht weiß, kann ich es ja auch nicht einfordern. Also bräuchte ich schon dann nachher beim BIM entwickeln praktisch auch eine proaktive Unterstützung, die immer ein, zwei Schritte vordenkt. Aber worum es mir geht, ich würde sagen, man kann es ja auch mal andersrum aufziehen, dass man beginnt, was ich auf jeden Fall brauche, ohne dass praktisch schon das Tool die Essenz ist, sondern eher, was alles beim Entwickeln schon irgendwo mit eingedacht werden müsste. Wie nachher, auf welche Art und Weise strukturiert, das müsstest du machen, aber wir würden es halt sammeln.
Du kannst das ja im Hintergrund auch in einer Art Outline festhalten. Und dementsprechend, wenn du denkst, das kann da schon rein strukturiert werden oder so, das dahin machen, aber die Feintuning, das machen wir alles am Ende. Und dann könntest du ja alle zehn Iterationen mit einem Wort für jeden Punkt eine schnelle Übersicht geben, damit ich immer so ungefähr weiß, was da drin ist schon.
Ja, und schön wäre natürlich auch, wenn ich praktisch nachher, wenn das denn zu den Iterationen geht, auch immer zu jedem Vorschlag oder so, auch eine Alternative dazu benannt kriegen würde, aber auch immer sehr kurz und vielleicht ein ganz kurzes Pro-Contra oder warum besser und halt nur als kurzer Infopunkt ohne Aufdringlichkeit und das mit der Outline, da wäre ja auch gut, wenn praktisch schon du beim Erstellen gewisse Dinge, die sich daraus ergeben, schon gleich mit aufführst, wenn du sie bemerkst.
Dann würde ich erst mal meine Fragestellung sagen, weil meine Fragestellung war dadurch, dass ich ja manchmal hier hinter 120 Iterationen oder so kleine Codeschnipsel, die dann wiederholt durch irgendwelche Codeschleifen gelaufen sind zum Prüfen und so, das ist ganz schön ermüdend, sage ich mal, obwohl ich vorher mir dann immer schon einen strukturierten Plan gemacht habe. Aber wenn man den dann halt so aufschlüsselt, dann kommt man immer so in die übelsten Nanodetails. Und das ist eigentlich gar nicht, was ich will. Ich will eigentlich erst mal so dieses Ganze unterbringen, damit das Gesamttool so einen Eindruck kriegt und strukturiert werden kann. Also, dass praktisch die Architektur schon nach dem Endergebnis ausgerichtet werden kann und somit viel Refaktorarbeit gespart wird und der Code einfach eine gewisse Sauberkeit und Stabilität hat.
Ja, das meine ich ja. Da kommen wir dann praktisch erst später zu, weil ich es mal andersrum probiere. Also mir wäre wichtig, dass ich erstmal weiß, was dann so zum Beispiel mit dem Standardmodell von ChatGPT in einer Iteration eine gute Zeichenmenge wäre, die man praktisch als Vorgabe machen könnte, damit die Iterationen immer schnell durchlaufen, aber auch im Endeffekt viel erfassen. Und das mit so wenig Code wie möglich natürlich und ohne dauernd dieselben Dateien immer wieder anzufassen oder in irgendwelchen Codeschleifen zu geraten.
Ich hätte dann zum Beispiel gedacht, dass man dann erstmal wie in so einer Art Dummy-Gerüst wirklich so wenig Code wie möglich verbraucht, um aber so viel grafische Oberfläche schon darzustellen damit, aber nicht im Endeffekt unbedingt jetzt um die Funktion zu testen, sodass das Tool optisch dann wahrscheinlich schon viel weiter wäre, also fertig, Release-mäßig dann am Ende, und der Code würde erst hinterhergezogen werden. Das müsste aber so strukturiert werden, dass er dafür praktisch eine Art aktualisierbare Datei, jeweils den fertigen oder den offenen Punkt nennt, eine Prozentzahl, ein Fortschritt, im nächsten Schritt und sowas alles, und das alles ein bisschen in der Dokumentation so perfekt macht, dass man auch mit, ja, vielleicht gar nicht so viel Einlesen braucht, wenn man sich ein Schema gesetzt hat, das praktisch im Klient einfach gewisse Sachen, die doppelt immer passieren, vermeidet.
Ja, genau. Und dass man auch später praktisch immer wieder durch eine Datei, die dann später kommt, aber im gleichen Code auch eine Veränderung erfordert. Man könnte ja auch wie mit so einer Arbeitsliste arbeiten und erst ab einem bestimmten Rahmen, wo man weiß, jetzt kann man strukturiert das eine von fast bis hinten, sag ich mal, durcharbeiten. Erst dann beginnt man. Aber man müsste dann dafür ja ein Schema haben, dass man sich Textdateien ablegen würde, wie mit einem Arbeitsauftrag. Und sobald in der eine bestimmte Menge erreicht ist, wird es automatisch in den Angriff genommen und kommt in ToDo oder so.
Da kommt es ja zum Beispiel darauf an, wie deine Tokenbegrenzung ist. Also mir wäre ja lieb, dass es ein bisschen immer zügig geht in einer Iteration und nicht ewig rumrudert. Und dass im Endeffekt auch keine Massen an Code verändert werden, wo dann tausende Sachen... Aber doch als ganzes Stück immer. Und das kann man ja dann auch praktisch in diesem Arbeitsauftrag dann irgendwie strukturieren. Vielleicht kann man das ja auch über ein JSON-Schema machen oder so. Ich habe keine Ahnung. Ich bin da absoluter Laie. Dann ist es mir da auch praktisch inspirierend, dann später noch was sagen dazu. Und es gibt ja auch so Autoformate oder Prüfdateien, die man mitlaufen lassen kann. Aber natürlich nur auch irgendwie in einem strukturierten, codesparsamen Modus. Dass es im Endeffekt mal am Anfang zügig geht und trotzdem keine Fehler eingebaut werden.
Ja, ich glaube, es geht so hier um die Einrückungszeichen und sowas alles und diese Black 8 oder so und so eine Sachen, also die im Endeffekt automatisch schon irgendwas korrigieren. Und wenn man das ja, glaube ich, früh genug einsetzt oder so, dann bleibt der ja schon sauber. Dann müsste praktisch noch sein, dass man eine perfekte Struktur, ja auch vorher, nachdem man die Tool-Idee weiß, für die Tool entwickelt, die so perfekt ist, dass es halt nur kleine, sehr wartbare und extrem übersichtliche Dateien gibt, die vielleicht sogar dann auch manchmal als Ganzes einfach verändert werden können, gepatcht werden können, ohne dass man dolle lange warten muss, weil man sich einfach halt ersetzt. Aber mein Gedanke war so, dass man halt sich eine Zeichenmenge ausmacht, von der man weiß, dass man da nicht lange braucht für und sucht sich halt immer die Zeile, notiert die, wo man das praktisch implementieren will oder wo man was verändern muss, den Grund und das genaue Detail, sodass du dann Bescheid weißt, was du dann praktisch da mal machst und das so genau, dass man da keine Fehler machen kann. Und wenn man das auch immer in der Change Log festhält mit einer ganz kurzen Zeile, dann kommt man ja auch immer auch rückwärts wieder rauf, wo man gerade war oder so. Und man müsste aber praktisch in jeder fünften Iteration so eine kleine Gesamtanalyse des Statuses machen und so und überlegen, ob es durch die neuen Sachen alles weitere praktische Aspekte gibt, die entstanden sind. Ob nun positiv, negativ, ob man eventuell an Grenzen kommt oder so.
Dann natürlich auch praktisch im Funktionieren und in dem Aufbau oder auch als Priorität gedacht, extrem für Laien geeignet, in einfacher Sprache, alles so ein bisschen noch aber kurz trotzdem gehalten, aber immer noch ein bisschen mehr als normal und vielleicht auch mit vielen Hilfe-Elementen, gerade bei so Sachen, die vielleicht schon von vornherein komplexer sind, dann wäre gut, wenn das alles dokumentiert werden würde in einer logischen Praktikfolge.
Ja, ich sagte, du müsstest dann praktisch auch gucken, was es an best practices gibt oder gängige Standards, die man schon anwenden kann, damit man viel Fehler oder viel Code vermeidet. Und dann auch meine Sessions durchsuchen, die Chats, was ich bisher so an Tools versucht habe zu bauen und die mal auflisten.
Eventuell kannst du ja auch von objektiver Seite aus bei meinen Sachen, bei meinen Versuchen mit Code und so schon sehen, welche Fehler ich auf jeden Fall gemacht habe und die mit mir so ein bisschen probieren anzugehen auch. Also da dann eher darauf einzuwirken und wo du weißt, dass ich praktisch schon weiß oder so, da kannst du einfach weniger Erklärungen bringen. Und am besten wäre es auch so, wenn keine Wiederholungen im Text wären, wenn du antwortest, sodass du praktisch wenig redest, aber die neuen Sachen immer sagst.
Naja, ich hatte so eine Idee, wenn man vielleicht anfangen würde, so schnell zu einer visuellen Lösung zu kommen, praktisch durch Gerüste und dass man alles so ein bisschen darstellt, kann ich mir ja mal gut vorstellen. Weil wenn man lange Iterationen erst hat, bevor man ein Ergebnis angucken kann, dann sind schon wieder so viele Gedanken dazwischen. Also dass man praktisch erst an den Visuellen arbeitet, aber immerhin im Hintergrund die Outline definitiv ergänzt, was dazugehört und was der Schritt dazu wäre. Dass man am Ende praktisch so einen visuellen Fertigsatz wie so eine kleine Arbeitsliste bekommen hat, die kann man dann auch strukturieren und verbessern oder optimieren. Und dann wäre halt auch gut, vielleicht habe ich überlegt, dass man durch das Kommentar verarbeitet und den Diskript, dass man nichts vergisst, dass alles, wo es einen Platz findet, alles vereinheitlicht ist, extrem gut sichtbar, strukturiert und ja, ein Visuellen Fertigsatz.
Vertraue und glaube, es hilft, es heilt die göttliche Kraft!
Ja, dann wäre ja schön, wenn man praktisch auch dadurch Checkpoints erreicht, indem man fertige Sachen schon fertig hat, also die man dann für andere Sachen eventuell als Templates nutzen kann.
Schön wäre es auch, wenn das praktisch auch einen Kli-Anschluss kriegen würde, sodass man auch eventuelle Sachen, die man auch von außen machen kann, zum Beispiel Datenbanken mit Textbefüllung, die kann man ja auch in der Konsole machen, dass man da auch Zugang hat.
Alles voll modular und im Endeffekt auch mit einem Dashboard und Hauptbereich, der alles so ein bisschen vorgibt und auch Standardsets oder Vorgaben und das alles so ein bisschen steuert mit einer Registrie und der ist aus festem Code und verändert sich nicht doll und der Rest wird praktisch modular oder über Plugins geregelt.
Kannst du mal zehn Vorschläge machen?
Ja, du hast völlig recht. Wir sammeln noch weiter. Es soll auf jeden Fall am besten ein portables, mobiles Tool sein, mit Debugging, extrem detailliert, sodass alles gleich erkennbar ist, wo der Fehler liegt. Viel Self-Repair haben, vielleicht alles schon so ein bisschen mitbringen. Es wäre gut, wenn man eigentlich das auch praktisch in ChatGPT Canvas mit dem Code gleich ausprobieren könnte, sodass man gleich was sieht.
Der D-Box-Bereich soll einfach auch wegschaltbar sein, ganz einfach, sodass man eine Raubtour hat. Und dann, ja, da wirst du nachher die besten Dinge herausbekommen. Was ich auf jeden Fall noch will, ist, dass praktisch mit einem Modul dann praktisch schon anfangen wird. Also, dass man dann, wenn wir die Struktur raus haben, einen Modul schon komplett durchbringen kann.
Erweiterbar soll es sein. Ja, dann auf jeden Fall immer mit gutem Spaß umgehen, aber viel Qualität bieten.
So, dann habe ich mir noch gedacht, wäre am besten, wenn man vorher so eine Art Update-Schema oder System erfindet, wo man dann praktisch die neuen Sachen alle immer Stück für Stück ransetzen kann, ohne dass es da zu Komplikationen kommt. Also, dass du mir dann praktisch Stücke machen würdest, ich würde die ins Tool reinfügen und das Tool würde sie automatisch implementieren. Dafür müsste ja ein bestimmtes Schema vorher erfunden werden.
Weil es ja ein erweiterbares Tool ist, wäre auch schön, wenn man versuchen würde, von Anfang an die Funktionen oder so, was man alles machen kann, praktisch wiederverwendbar zu machen, dass praktisch nicht so viel Code entsteht und vielleicht sich da ein extrem intelligentes System wählt, das praktisch auch nicht fehlerproduzierend am laufenden Band ist.
Für die Texte, die so im Zuge sind und irgendwo anfallen, habe ich mir überlegt, kann man ja auch versuchen, die auszulagern, sodass man die auch mit Versionen belegt und die dann später auch leichter tauschen kann. So, dafür müssen wir uns was einfallen lassen. Und dann Testdateien wären schön und vielleicht auch eine Art FAQ.
Es wäre schön, wenn so wenig Abhängigkeiten wie möglich natürlich sind, aber ansonsten wirklich jede kleine Abhängigkeit, ob das RLG oder ob das irgendein Formattool ist oder so, auf jeden Fall jede Kleinigkeit auch in der Require angeben und immer abprüfen.
Weil ich ja auch viel im Browser arbeite und recherchiere und Texte schreibe, wäre natürlich auch gut, wenn man irgendwie schaffen würde, eine Art Pipeline zum Browser zu machen, so dass man HTML auch nutzen kann, auch wenn man jetzt nicht unbedingt Berechtigung hat. Das kann man ja bei denen Sachen machen, wo man nicht viele Rechte braucht, aber trotzdem, weiß ich, irgendwas für die nächste Zeit braucht oder Templates oder sowas, dass man das eventuell über eine JSON, die man bei Tool Start dann mal reinlädt, dass sie dann eben auch berechtigt, dieses HTML-Tool mit Berechtigung zu betreiben.
sondern auf jeden Fall auch praktisch ein Archiv dort stattfinden, wo ich zum Beispiel so eine Sachen wie die Befehle von Git oder irgendwelche anderen Sachen mir anlegen kann und praktisch auf mehreren Ebenen irgendwo indizieren kann und suchen kann und mir das dann praktisch auch irgendwo anzeigen kann. Also da weiß ich aber noch nicht ganz, wie es aussehen soll.
extrem vollautomatische, aber mit Nutzerfeedback transparente Startroutine, die auch Fortschritt oder den Schritt anzeigt und Infos darüber sagt oder praktisch bei Fehlern Optionen anbietet oder vollautomatisch alles selbst separiert, aber alles muss praktisch vorher schon bedacht
Die Module und das Tool selbst, die sollen auch extrem informativ und mit ihren Informationen und Statistiken transparent sein und die überall anzeigen, also überall, wo Mengen oder sonst irgendwas sind, soll das auch angezeigt werden. Standard-Fenster-Bereichelemente eine super Hilfe haben. Da kann man auch daran arbeiten, dass man das in den Iterationen immer weiter erweitert.
Ja, ein Plug-in-System natürlich auch mit Registry. Also wo geht, kann man mit Registry arbeiten, damit alles perfekt bleibt. In den Dateibenennungen soll dann natürlich auch schon der Status der Datei, also ob er noch Anfang ist oder Release fertig ist oder so, mit rein. Dann vielleicht die Version, der Name, möglichst alles in Deutsch, auch bei den anderen Sachen, also in einfacher Sprache Deutsch und möglichst eindeutig erklärt. Und für ältere Menschen auch verstehbar und so, also auch jemand, der kein Fachtermini kennt. Und wenn Fachtermini auftaucht, immer noch dazuerklären, klammern vielleicht, alles irgendwo gut voneinander, auch farblich abgegrenzt, die Bereiche auch eindeutig abgegrenzt. Hier responsive Design, alles dynamisch anpassbar, vollautomatisch, damit sich die Bereiche nicht irgendwie in die Quere kommen, nichts irgendwo runterrutscht oder nicht zu sehen ist. Alles soll von einem Bildschirm auch bei kleineren zu sehen sein und eventuell sogar sehr flexibel in der Größenskalierung und Positionierung.
Auch achten bei den Kontrasten, dass die Schrift einen anderen Farbkontrast hat wie der Hintergrund und sowas alles. Da kann auch viel vereinheitlicht werden. Und das wäre am Anfang praktisch ein sehr schmales, weil vieles wiederverwendet wird oder praktisch vereinheitlicht ist, Tool bekommen. Und das kann dann später an gewissen Stellen einfach vielleicht ein bisschen qualitativer gemacht werden.
Schön wäre es ja auch, wenn man, ich sage mal, die Module oder so, die man eventuell später dann implementiert, auch ein- ausklappen könnte oder so, oder minimieren, maximieren könnte. Aber dass alles praktisch auf ein Tool bezogen ist, außer man drückt eine ganz spezielle Taste, dass es sich dann abkoppelt. Aber dass möglichst alles robust und sicher. Das wäre mir auch so für das Tool immens wichtig, dass es keine Abbrüche gibt, keine Datenverluste oder so, dass wir mit Papierkorb arbeiten und mit Logging und alles detailliert. Also, dass auch vielleicht sofort auch die Bereiche genannt werden oder der Fehler genannt wird. Auch so, dass sie ein Line verstehen und ein schönes Debugging praktisch. Menü, da kann man ja auch nochmal gucken im Internet dann praktisch, was es da so an Best Practices gibt. Barrierefrei wäre schön, dass es gleich auch große Schrift ist, sodass sehschwache Menschen auch sofort alles erkennen. Übersichtlich trotzdem, vielleicht mit zwei Modis, ein Entwicklermodus, der ein bisschen umfangreicher ist, und ein Normalmodus für Laien, wo dann alles praktisch sehr übersichtlich, gut beschrieben ist.
Vielleicht kann man ja so vorplanen, wenn man nachher alles weiß oder so und alles abgeklärt hat, dass man so kleine Dateien macht und die halt mit fortlaufenden Nummern hinten oder irgendwas anderem versieht, dass man praktisch und in einer Datei dann sagt, es geht da und da weiter. Oder in jeder Datei sagt, sie soll gucken, ob noch eine fortlaufende Zahl ist. Und wenn, dann hat man halt mehr Dateien für ein bisschen größeren Code. Aber vielleicht kriegt man es ja von vornherein durch Manifeste und Vorgaben so hin, dass es gar nicht entsteht, dass alles schon in der Architektur auch so geplant ist.
Ja, wie gesagt, extrem laienfreundlich, platzfahrend, so eine Art Fallback-Modi mit drin, dass man vielleicht schon die JSON, die gängigen Dateien schon mit dem Projekt implementiert, für Self-Repair und so, und dann vielleicht auch FaceSafe, Gate oder so was, oder Sidebars, alles Mögliche. Vielleicht, aber je nachdem, was wir implementieren. Aber eine Grundstruktur muss ja, ich sag mal, von den Bereichen her oder so schon vorgenommen werden, dass das alles übersichtlich bleibt. Auf jeden Fall ein schönes, informatives Dashboard mit allen möglichen Informationen, auch Datum und so was, oder irgendwelche Log, ich sag mal, die letzten fünf Log-Einträge oder so.
Ja, und dann vielleicht so gleich eine Struktur aufbauen mit dem Entwickler-Doku oder zum Beispiel, dass man die Dateiordnerpfade und die Projektdateien in einer Liste schon aufführt und bestimmte Sachen dazu schon mit, ich sage mal, als Kommentar mithinschreibt, dass es vielleicht irgendwo eine Art fester Basis gibt, die nachher auch so bleibt. Und wenn sie verändert wird, müsste praktisch in irgendeiner Registrie auch die Info dann abgelegt werden. Das müsste dann auch schon eine Vorgabe sein.
Je nachdem, was man dann mit dem Patch oder Update entscheidet, könnte man ja auch so machen, dass man jede Iteration auch am Ende alles in einer ZIP ausgibt, was bis dahin existiert. Oder in der normalen Datei, die dann praktisch eine ganze ist, wo man nicht mehr ran muss oder so, das müssten wir uns nachher dann ausfuchsen.
Ja, dann, wie gesagt, Priorität wäre zum einen, die visuelle GUI erstmal in irgendeiner Form hinzukriegen und das andere dann bei Gelegenheit oder gebündelt praktisch zu machen. Dann so eine Art, ich weiß nicht, ob das vielleicht günstig wäre, dass man auch die Buttons oder so vielleicht wiederverwendet. Ich weiß nicht, ob das geht. Oder so eine Art, ja, Data-GUI-Meter bei JSON anlegt oder auch was mit so Style-Tokens, JSON vielleicht ist, dass man eventuell da eine Superstruktur schon alleine von der ORNA-Struktur her kriegt, dass die anderen Sachen sich dort praktisch nahtlos einfügen. Dann habe ich überlegt, eine gute Rate-Me, eine Anleitung schon mit drin, eine Entwickler-Doku detailliert, diesen Verzeichnisbauben praktisch als Info, eine To-Do-Liste, die immer aktualisiert wird praktisch, aber auch wie so ein Patch immer nur an den Stellen und, ja, und dass man sich vielleicht ein Schema anlegt, wie man vorgeht, dass man nicht praktisch erst hinten eine Datei macht, dann vorne eine, in der Mitte, hinten wieder, sondern dass man immer ganze Sätze fertigstellt, die man dann auch zwischen prüfen kann oder so. Cool wäre natürlich auch, wenn die Module selbsttätig funktionieren würden, aber das musst du dann entscheiden, was da möglich ist, dass man die vielleicht sogar einzeln prüfen könnte, auch außen ohne das Haupt-Tool, aber sich das, wenn im Tool befindlich, nahtlos dort einfügt und natürlich dann auch im Haupt-Tool angezeigt wird, was alles implementiert ist und in den Hilfeeinstellungen praktisch auch alles sieht.
Ja, maximal robust und flexibel, extrem modern im Design, also da kann man auch gerne, wenn möglich, aber Priorität ist am besten ohne Abhängigkeiten. Wenn es nicht anders geht, geht es auch mit, aber dann kann man ja vielleicht gucken, dass man die gleich mitliefern kann, also dass es nicht so groß ist oder so. Also je nachdem, ja, das müsste man sich ja dann auch praktisch dann auch vorher überlegen. Extrem vielleicht auch eine Startprüfung mit Farben, wo man dann auch gleich mitsieht, also wie so ein Wizard gleich sieht, wie die Ergebnisse sind und dass es extrem intelligent arbeitet, vielleicht vorher schon präventiv Fehler vermeidet oder auffängt oder im Endeffekt tolerant ist oder die selbst handeln kann. Ja, und dann eine einheitliche, praktisch eine Art, die Entwicklung zu betreiben, also dass man am Anfang was festlegt und das versucht, bis zum Ende durchzumachen. Sollte es anders geändert werden, das in irgendeiner Datei natürlich wieder informiert. Und ja, was wäre sonst noch? Vielleicht noch extrem diese Befehle oder so, die im Tool passieren können oder so extra noch mit einer Art Zusammenfassung und Glossar dafür machen. Ja, eine Konsole, mit der man das startet oder ein Klick- und Startdatei. Praktisch, wenn man so eine Konsole startet, dort auch Debugging schon ausgeben, detailliert, damit man gleich auch unter der Oberfläche was sieht.
Ja, also irgendwelche Dateien, die einen Vorgaben machen, so zur Codedisziplin oder zur Entwicklung Interaktionsdisziplin oder so, dass man das alles schon so ein bisschen sich vordenkt. Also, dass dann im Endeffekt auch wirklich ohne viel Worte am Ende immer weiter auf das Ziel hinaus gearbeitet wird. Auch mit dem Dashboard, dass praktisch auch jedes neue Modul irgendwo dort nahtlos eingefügt werden kann. Vielleicht einfach, dass jedes, was man neu startet, im Endeffekt immer hinten rangehangen wird, aber verschiebbar ist oder so. Also irgendwie so, dann vielleicht Settings extra in einem Tab. Und vielleicht kann man das ja auch so machen, dass wenn man jetzt so diese HTML-Sachen hat, dass man von einer HTML-Seite auf eine andere kommt, aber praktisch oben über den gleichen Punkt oder so, dass da wie so eine Art Buttons sind, die zur nächsten Seite führen. Vielleicht kann man ja auch ein Workflow etablieren, wenn man jetzt zum Beispiel eine Recherche-Tool macht, HTML-mäßig, oder ein Template-Tool, dass man zwischen denen switchen kann. Oder vielleicht gibt es ja da auch andere gute Ideen. Dann wäre noch Sicherheit natürlich auch irgendwo, dass man gleich so ein bisschen auf Sicherheit, Stabilität achtet. Die GUI praktisch vorher schon plant, was es bedeutet, wenn ein Multitool dann praktisch stattfindet.
Vielleicht auch gleich an solche Sachen denken, dass man vielleicht auch Dateien handeln will, also diese dann Linux-konform zum Beispiel gemacht werden, oder man da vielleicht auch Dateienvorschau haben kann oder die Thumbnails sieht, je nachdem, was benötigt wird, oder vielleicht auch so Sachen wie Vorhöraktionen, also dass man aus dem Tool heraus über einen Browser oder Dateimanager direkt schon auch sieht, was ist, vielleicht sogar Stapelumbenennungen von dort aus machen kann oder Dateienstapel praktisch Linux-konform umbenennen oder auch andere hilfreiche Sachen, wie zum Beispiel ein kleines Notizenfenster, was direkt in eine TXT, feste TXT speichert, um für Entwickler praktisch Sachen einzugeben. Wenn man praktisch was einträgt und einen kleinen Button daneben abschicken, dass das dann in dieser Datei gespeichert wird, das Feld geleert wird, und sowas natürlich auch alles gelockt wird, dann eine kleine Funktion oben To-Do-Liste, wo vielleicht aus einem anderen Bereich dann To-Dos angezeigt werden und dass man am Anfang das sich so baut, dass praktisch die Entwicklungsersten Schritte schon die sind, die man am Ende auch wirklich braucht dort.
Natürlich so eine extrem guten und konstruktiven Optionen auch global einstellen, praktisch wie zum Beispiel Export-Import oder Autosave. Also alles, was so für ein gutes professionelles Tool auch gut ist. Schon alles mit irgendwo mit, ohne dass ich das vielleicht sagen muss, sollten Fragen entstehen. Kannst du kurz nachfragen, dann am besten aber auch gleich immer mit Vorschlag, also kurze Antwort, nimm das oder das. So und vielleicht ganz kurz, ich würde dir das empfehlen.
Ja, wie gesagt, auch ein Standard für die praktisch abschließende Antwort einführen, dass man immer eine Prozentzahl vom Fortschritt hat und vielleicht den nächsten Schritt und einfach so und so viel Offene und so viel Erledigte und dass man dann vielleicht, ich sage mal, auch aktueller Stand dieser Iteration als Gesamtes mal bewertet. Also vielleicht kann man da ja unterteilen, so und so viele Stufen, darin Einzelstufen, das sind dann einfach nur die Mengen da und aber dass man sagt, du hast jetzt Stufe 1 von 8 hast du komplett durch.
Wir sammeln noch kurz weiter. Also wenn denn zum Beispiel in der Entwicklung Nebensachen entstehen oder wichtige Fragen, die jetzt aber später erst kommen oder so, oder auch Verbesserungsvorschläge oder Korrekturen, die man später dann vielleicht angehen sollte, dann kann man ja auch dafür eine Infodatei mit entsprechenden Namen festlegen, die dann auch immer praktisch kurz eingelesen wird, aber erst praktisch dann später. Was man machen kann aber, dass man vielleicht bei jeder Iteration wie so eine Art Eingangsritual hat, gehe in die Datei, tue das, das als Vorgabe, dann liest man dort, was gerade gewesen ist in der letzten, und fängt praktisch an dem genauen Schritt danach an und vertraut darauf, dass das andere gut gelaufen ist. Dementsprechend muss man, wenn man am Ende ist und in diese Datei reinschreibt, extrem deutlich, eindeutig sagen, mit was man erfolgreich aufgehört hat.
Ja, und dann halt praktisch eine extrem gute und detailliert durchdachte Vorplanung, die man dann auch nummeriert und vielleicht immer mit einem Infopunkt noch versieht, den man in dem Moment sich gedacht hat, damit das auch alles eindeutig ist und nacheinander abziehen kann. Dann wäre ja noch gut, vielleicht einen Filter oder eine Suche mit einzubauen im Tool und einen Datenbankprojektordner, der als Standard gilt, also der im Home vom User angelegt wird unter Linux, es braucht auch kein anderes Betriebssystem bedacht werden, den Projektordner anlegt oder aus einem Zip heraus oder aus einem Projektordner arbeitet, was da halt günstig und stabil und robust ist. Vielleicht kann man ja auch mit JSON als Archiv arbeiten. Das kann man ja später dann vielleicht noch ausweiten, wenn dann andere Anwendungsfälle kommen oder so. Ja, das Repair halt, das nie zu Abstürzen kommt, auch nicht wegen fehlenden Sachen oder so, dass immer eine Lösung angeboten wird oder gleich selbst repariert wird, alles transparent natürlich.
Eventuell von Anfang an mit unterschiedlichen Modis von Agents MD arbeiten und dort praktisch auch versuchen, gleich eine Art konstruktive intelligente Form oder Schema zu finden, sodass die meisten Sachen automatisch ohne irgendwelche Anweisungen schon passieren, aber nur, wenn sie nötig sind. Und dass man da vielleicht unterschiedliche Modis benutzt, je nach Entwicklungsstand, dass dann der Agentsystem auch immer optimal anpasst. Und Code Standards, vielleicht hatte ich, glaube ich, schon gesagt. Eine ordentliche Rate Me und Validierung natürlich auch im Tool. Am besten auch in der Masse von Zeilen pro Datei irgendwelche Begrenzungen geben.
Jede Änderung braucht natürlich einen belegbaren Grund und sollte dann durch das Ermitteln und Sammeln und in einem Rutsch Abarbeiten und dann Testen erfolgen. Auch praktisch solche Sachen, wie wenn man jetzt einen Formatercode verändert hat, dann kann er erstmal praktisch prüfen, ob der Code an der Stelle ist, bevor er das Tool erstmal durchstartet. Weil wenn es dann da ist, hat er es ja umsonst gemacht und wenn er es einmal prüfen würde und es dadurch schon feststellen könnte. Aber da weiß ich nicht, wie es halt wirklich geht. So, dann natürlich, Lock habe ich schon gesagt, auch nachher eine Release-Checkliste mit einfügen und barrierefrei, klare Sprache, Pflicht, dann maximale Flexibilität.
Ja, und schön wären natürlich auch solche Sachen wie drag-and-drop oder so oder Kopierfunktionen für die Zwischenablage oder auch, ja, ich weiß nicht, was alles so sonst noch geben kann wie Validierung, Input, Output. Eventuell kann man ja auch eine Cache-Datei anlegen, um so Vorschauen schon schneller zu behandeln. Persistenz in den Nutzereinstellungen. Eventuell einfach auch, ja, praktisch eine Wizard, der eine Tool reinführt und gleich schon eine Infodatei bereitstellt und alles prüft natürlich. Ja, dann lokale Fähigkeit natürlich, weil ich ja auch Dateien suchen will auf den Rechnern und so, aber alles unter Linux und vielleicht kann man das ja in den Start einbauen, dass da die Berechtigung gegeben wird und solange man das Tool nicht schließt, es bleibt halt so oder ich weiß nicht, was da los ist.
Ja, soll natürlich nichts an dem Hauptsystem irgendwie beschädigen oder so. Wenn möglich auch ein bisschen mit auf die Ressourcen achten, dass man praktisch nicht durch das Tool, durch Überlaufen von RAM oder zu viel CPU dauernd denn praktisch warten muss. Vielleicht kann man ja auch da Optionen reinbauen und dann ja alles, was halt nutzerfreundlich ist, barrierefrei für alle Eventualitäten irgendwie ja durchdacht und extrem gut dokumentiert mit allen Details und das praktisch ja irgendwie versucht immer in einer Art Bündelung zu machen und dort auch einen Rhythmus festlegen, in dem das dann stattfindet. Vielleicht kann man ja da eine super intelligente Abfolge treffen. Jetzt das, dann das, dann das und dann kommt das, dann sind wir mit dem fertig oder so. Vielleicht kann man ja da auch schon Schritte sparen oder so.
Ja, Sachen, die sich vielleicht für dich schon einfach aus Nachdenken ergeben, weil ich sie bisher oft gemacht habe, aber nicht davon ausgehend immer. Aber wenn du jetzt weißt, das und das wird sowieso verwendet oder so, dann braucht man das ja nicht unbedingt mit erwähnen. Das kannst du ja vielleicht kennzeichnen in dieser Sammelliste. Die bleibt übrigens auch, soll praktisch fortlaufend sein, also dass man auch den Schritt sieht, wie so alles gewachsen ist. Und vielleicht kann man da das ja vermerken, dass das, was du hinzugefügt hast, das sind so die Sachen, die sich aus den Iterationen ergeben haben, das sind meine.
Was ich auf jeden Fall noch brauche im Dashboard, möchte ich noch so eine Art Praktisch-Schnelltaste haben, die ich variabel zum Beispiel mit Textfragmenten belegen kann oder befehlen. Und wenn ich auf die draufdrücke, dass die sofort eine Zwischenablage kopieren. Und dann brauche ich noch, ich sage mal, mehrere, aber unter zehn Eingabe-Einzeiler-Felder mit einer Überschrift, die ich auch variabel praktisch belegen kann und die dann auch zu einer festen Datei im Tool immer folgend in eine Datei geschrieben werden. Natürlich Duplikate geprüft, aber ansonsten fest dort in den Dateien verbleiben, vielleicht sogar editierbar sind aus dem Tool heraus, aber ansonsten nicht irgendwie verändert werden. Also die sind dann Grundstruktur, wie so eine Art Schnellspeicher, weil ich mir manchmal Genres abspeichere oder sonst irgendwelche Sachen. Und das könnte man zum Beispiel vielleicht sogar auch mit der CLI verbinden, dass dort im Tool sind diese Eingabeflächen, können auch kleine Einzeiler sein, aber dass keine Wörter verschwinden, also dass man sieht, was man eingibt und die dann praktisch nebeneinander mit Überschrift da sind und je nachdem, ob ich sie belegt habe oder nicht, schon dazu führen, dass es immer, wenn man das Feld verlässt, da reingespeichert wird.
Auf jeden Fall darf praktisch in den Iterationen auch keine Qualitätsreduktion passieren oder Code wieder reduziert werden. Also es darf nur erweitert werden oder aus guten Gründen etwas verändert, weil im Endeffekt sich was anderes ergeben hat. Ansonsten ja, keine Abweichung davon. Abweichungen, die im Tool passieren, wenn man zum Beispiel einen Schritt nicht vollenden kann oder so, kann man den ja gleich in den nächsten Schritt als praktisch erste Erledigung mit reinschreiben, dass das dann immer als erstes abgeprüft wird. Und dann natürlich auch schon eindeutig einen Entwicklerbereich, der aber praktisch minimiert werden kann und dann auch nicht mehr so auffällt. Ja, jetzt bin ich fertig.
Ist das dann praktisch wie so eine Art Frontend?
Schnell anfangen, aber sag mir vorher noch, ob es noch andere Alternativen gibt, die auch komplett abhängigkeitsfrei wären.
Also ich glaube dann erstmal TK-Inter. Praktisch, dass der Wizard startet über TK-Inter, dass dann praktisch dieses erste Dashboard-Tool entwickelt wird mit TK-Inter und das vielleicht gleichzeitig, also so wie du gesagt hast, mit dem Anfang als Modul, aber auch gleichzeitig ein HTML aufgebaut wird, gleich verkoppelt wird mit dem Dashboard-Modul und dieses HTML-Modul soll praktisch eine Art Genre-Archiv werden, wo ich nach Profilen wie Techno, Hard, Soft, Hörspiel bestimmte Genres einspeichern kann, die nach Duplikaten geprüft werden, auch durch Komma getrennte einzelnen abgelegt werden, alles übersichtlich, eine editierbare Archiv-Liste angezeigt wird, ein Export-Import stattfinden kann, Autosave-Backup und praktisch auch ein Zufallsgenerator mit drin ist, der mit mehreren Modis über Schnelltasten praktisch aus Genres, Moods und Stilen praktisch je nachdem, was man aktiviert hat, gewisse Mengen sich zufällig ausgeben kann, die dann direkt in die Zwischenablage kopiert werden und auch gelockt werden, persistent, dass man auch später nochmal zusammenfassen kann, was man so als Gesamtes hat.
Ja, B wäre schon cool, wenn das irgendwie, ja, damit auch immer robust funktioniert, auf jeden Fall. Und dann auch im HTML schon dran denken, da sollen ja auch ungefähr dann dieselben Parameter und alles gelten, dass man da vielleicht auch gleich diese Zwischenschalter zu einer leeren neuen HTML gleich mit implementiert, sodass dieses als Logik schon eine Fahnenkarte ist.
Ich würde sagen, du fängst erst mal mit der Ordnerstruktur an, erstellst die ganzen Verzeichnisse, die du meinst, die wir brauchen, dokumentierst das schon und legst die AgentsMD als allererstes an. Natürlich optimal für unsere ersten Prozesse vorkonfiguriert, mit den Vorgaben, die wir besprochen hatten.
Bitte nicht vergessen, am Ende der Iteration immer eine ZIP-Datei auszugehen, damit ich praktisch die Entwicklung auch als Datei festhalten kann. Und dann habe ich überlegt, was ist denn mit z.B. auch HTML, wenn man jetzt alles so Sachen wie z.B. Recherche oder auch nachher einfach Sachen, dass ich z.B. Zitate oder auch so Sachen wie jetzt einen Blogartikel schreibe. Alles, was so ein bisschen einfacher, mit wenig komplexen Funktionen und so ist, kann man die dann auch einfach in HTML generieren, sodass man das auch gleich schon in Canvas immer aktuell zeitnah sieht, wie es funktioniert.
Am liebsten wäre mir, wenn man eine Art Patch-Datei-System erfinden würde, du die nummerierst oder in irgendeiner Art und Weise mit einem Suffix belegst und das Tool anweist, wenn im Haut-Ordner solche Dateien beim Start vorhanden sind, muss es die in den Projekt-Ordner, Modul-Ordner verschieben und implementieren, und zwar auch mit intelligentem Fehlerhandling und alles drum und dran, Logging, Debugging und so gut und konstruktiv robust wie möglich.
Ich würde sagen, global im Tool ist am besten, weil dann können wir die Update-Logik in dem festen Code belassen und auch von dem Haupttool praktisch steuern lassen. Und die Module haben praktisch nur ihre, ja, ich weiss nicht, wie man das nennt, ist das dann eine Kleinfunktion?
Ja, das kannst du selbst wählen, was das Beste ist oder das Logischste. Was du auch noch aufnehmen kannst, ist eine Art praktisch Wiki-Modul, das wir auch über JSON dann steuern als Archiv für zum Beispiel, ja, Termini, Fachtermini oder Begriffe, die wir benutzen, die Fremdwörter sind oder spezielle Begriffe aus dem Coding-Bereich oder so. Und da können wir uns ja auch schon praktisch eine Art Manifest überlegen, weiss nicht, dreistufige oder vierstufige Ebene mit dem Namen praktisch, um das es geht, Text dazu, einer kurzen Beschreibung für Laien verständlich und zwei Beispiele vielleicht noch. Und dieses wird dann immer, wenn neue Fachtermini auftauchen oder du der Meinung bist, das könnte ich gebrauchen, dann erweiternd im Projekt in einem JSON reingeschrieben und vom Tool praktisch, vom Haupttool gehandelt, wenn es auch immer erreichbar sein soll.
A
2
A + Pro: Wizard = transparent/Laie
b
A Was ist ein Kernel und würde er oder würde so etwas uns vielleicht auch weiterbringen?
Ja bitte
